<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SealYun</title>
    <link>https://sealyun.com/</link>
    <description>Recent content on SealYun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Aug 2019 10:54:24 +0200</lastBuildDate>
    
	<atom:link href="https://sealyun.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>kustomize 颤抖吧helm!</title>
      <link>https://sealyun.com/blog/2019/08/03/kustomize/</link>
      <pubDate>Sat, 03 Aug 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/08/03/kustomize/</guid>
      <description>&lt;p&gt;本人是helm的重度用户，但是吧越用越不爽。。。 helm v2版本三大弊病：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多租户支持不了&lt;/li&gt;
&lt;li&gt;搞个tiller服务端，鸡肋&lt;/li&gt;
&lt;li&gt;扯出自己很多概念&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;v3版本抛弃tiller算是个进步，但是听说要上撸啊（lua）我就瞬间崩溃了，我只是想渲染个yaml文件而已。好在好多chart包貌似生态很繁荣。。。&lt;/p&gt;

&lt;p&gt;今天给大家介绍kustomize是如何让helm寝食难安，做梦都在颤抖的.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CNI 小精灵 genie</title>
      <link>https://sealyun.com/blog/2019/07/30/genie/</link>
      <pubDate>Tue, 30 Jul 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/07/30/genie/</guid>
      <description>&lt;p&gt;想同时使用多个CNI? 想往容器里塞多张网卡？试试这款CNI插件 &lt;a href=&#34;https://github.com/cni-genie/CNI-Genie&#34;&gt;CNI-Genie&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>彻底理解 kubernetes CNI</title>
      <link>https://sealyun.com/blog/2019/07/30/cni/</link>
      <pubDate>Tue, 30 Jul 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/07/30/cni/</guid>
      <description>&lt;p&gt;CNI接口很简单，特别一些新手一定要克服恐惧心里，和我一探究竟，本文结合原理与实践，认真读下来一定会对原理理解非常透彻。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes CRD如此简单</title>
      <link>https://sealyun.com/blog/2019/07/20/crd/</link>
      <pubDate>Sat, 20 Jul 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/07/20/crd/</guid>
      <description>&lt;p&gt;扩展kubernetes两个最常用最需要掌握的东西：自定义资源CRD 和 adminsion webhook, 本文教你如何十分钟掌握CRD开发.&lt;/p&gt;

&lt;p&gt;kubernetes允许用户自定义自己的资源对象，就如同deployment statefulset一样，这个应用非常广泛，比如prometheus opterator就自定义Prometheus对象，再加上一个自定义的controller监听到kubectl create Prometheus时就去创建Pod组成一个pormetheus集群。rook等等同理。&lt;/p&gt;

&lt;p&gt;我需要用kubernetes调度虚拟机，所以这里自定义一个 VirtualMachine 类型&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>从CNI到ovn</title>
      <link>https://sealyun.com/blog/2019/07/08/ovn-vni/</link>
      <pubDate>Mon, 08 Jul 2019 13:50:46 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/07/08/ovn-vni/</guid>
      <description>&lt;p&gt;诸如calico flannel等CNI实现，通过牺牲一些功能让网络复杂度得以大幅度降低是我极其推崇的，在云原生时代应用不再关心基础设施的场景下是一个明智之举，给网络调错带来了极大方便。&lt;/p&gt;

&lt;p&gt;openstack与k8s放一起比较意义不大，openstack还是着重与基础设施，所以对上接口还是机器设施，网络设施，存储设施等，着重与资源的抽象。&lt;/p&gt;

&lt;p&gt;然鹅k8s不仅需要资源抽象，还需要关心应用的管理，其基于容器的设计理念已经改变了传统三层的云计算架构，而更像一个云内核，对上不再关心基础设施的接口了，反正把用户应用管好了就行。&lt;/p&gt;

&lt;p&gt;对比早起的操作系统很发现历史是惊人的相似，早期分层式操作系统到现代的宏内核与微内核操作系统，系统设计更为内聚了。目测云操作系统也会朝着这个路子发展吧（openstack粉太多，亡openstack之心不死不敢直说）&lt;/p&gt;

&lt;p&gt;但是！&lt;/p&gt;

&lt;p&gt;openstack底层一些技术还是非常值得学习与应用的，如qemu kvm ovs ovn ceph DPDK等。。。&lt;/p&gt;

&lt;p&gt;本文重点讲网络这块,ovn ovs怎么与kubernetes擦出火花&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>macvtap实践教程</title>
      <link>https://sealyun.com/blog/2019/06/23/macvtap/</link>
      <pubDate>Sun, 23 Jun 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/06/23/macvtap/</guid>
      <description>&lt;p&gt;macvtap是虚拟机网络虚拟化常用的一种技术，当然容器也可以用. MACVTAP 的实现基于传统的 MACVLAN. 和 TAP 设备一样，每一个 MACVTAP 设备拥有一个对应的 Linux 字符设备，并拥有和 TAP 设备一样的 IOCTL 接口，因此能直接被 KVM/Qemu使用，方便地完成网络数据交换工作. 引入 MACVTAP 设备的目标是：简化虚拟化环境中的交换网络，代替传统的 Linux TAP 设备加 Bridge 设备组合，同时支持新的虚拟化网络技术，如 802.1 Qbg.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>强隔离容器那些事</title>
      <link>https://sealyun.com/blog/2019/06/22/kubernetes-vm/</link>
      <pubDate>Sat, 22 Jun 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/06/22/kubernetes-vm/</guid>
      <description>&lt;p&gt;探讨可加QQ群：98488045&lt;/p&gt;

&lt;p&gt;强隔离容器的那些事&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么需要强隔离容器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们在生产环境中运行容器已久，第一次对强隔离容器诉求是java类应用引起的，如果不配置jvm参数，java虚拟机会根据系统资源信息进行内存gc线程数等配置，在不给容器配额的情况下问题不大，一旦配额了。。。&lt;/p&gt;

&lt;p&gt;普通的容器在容器中看到的资源还是宿主机的资源，那么假设宿主机128G而你给容器配额2G，此时堆内存按照128G去分，可想而知后果，同理还有gc线程数等&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes Admission Controller原理介绍</title>
      <link>https://sealyun.com/blog/2019/05/23/kube-admin-control/</link>
      <pubDate>Thu, 23 May 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/05/23/kube-admin-control/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Admission Controller介绍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apiserver干的最重要的三个事就是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;认证 : 看是否是合法用户&lt;/li&gt;
&lt;li&gt;授权 : 看用户具备哪些权限&lt;/li&gt;
&lt;li&gt;admission controller : 一个调用链，对请求进行控制或修改，比如是否允许这个请求。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;admission controller非常有用，也是经常会用到的k8s的一个扩展方式，今天在源码级别对其做一下介绍，以及如何自己去开发一个admission controller.&lt;/p&gt;

&lt;p&gt;我们的应用场景是：我们希望把所有需要创建的pod都加上一个注解，因为我们早期是通过podpreset给pod注入lxcfs的配置的，但是用户在写yaml文件时很容易忘记加上，所以需要在apiserver上来个自动处理&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes开发流程</title>
      <link>https://sealyun.com/blog/2019/05/01/dev-k8s-workflow/</link>
      <pubDate>Wed, 01 May 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/05/01/dev-k8s-workflow/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;本文介绍如何对kubernetes进行二次开发，仓库如何管理，git分支如何管理，怎样利用CI去编译与发布以及如何给社区贡献代码等，结合实际例子，望对大家有所帮助。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>最简单的kubernetes HA安装方式-sealos详解</title>
      <link>https://sealyun.com/blog/2019/04/15/sealos2.0/</link>
      <pubDate>Mon, 15 Apr 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/04/15/sealos2.0/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;本文教你如何用一条命令构建k8s高可用集群且不依赖haproxy和keepalived，也无需ansible。通过内核ipvs对apiserver进行负载均衡，并且带apiserver健康检测。&lt;/p&gt;

&lt;h1 id=&#34;快速入门&#34;&gt;快速入门&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fanux/sealos&#34;&gt;sealos项目地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;准备条件&#34;&gt;准备条件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;装好docker并启动docker&lt;/li&gt;
&lt;li&gt;把&lt;a href=&#34;http://store.lameleg.com&#34;&gt;离线安装包&lt;/a&gt; 下载好拷贝到所有节点的/root目录下, 不需要解压，如果有文件服务器更好，sealos支持从一个服务器上wget到所有节点上&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>最简单的kubernetesHA安装方式-sealos详解</title>
      <link>https://sealyun.com/blog/2019/04/15/sealos-docs/</link>
      <pubDate>Mon, 15 Apr 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/04/15/sealos-docs/</guid>
      <description>kubernetes集群三步安装
 概述与设计原则 sealos旨在做一个简单干净轻量级稳定的kubernetes安装工具，能很好的支持高可用安装。 其实把一个东西做的功能强大并不难，但是做到极简且灵活可扩展就比较难。 所以在实现时就必须要遵循这些原则。
sealos特性与优势：
 支持离线安装，工具与资源包（二进制程序 配置文件 镜像 yaml文件等）分离,这样不同版本替换不同离线包即可 证书延期 使用简单 支持自定义配置 支持   为什么不使用ansile
 1.0版本确实是用ansible实现，但是用户还是需要先装ansile，装ansible有需要装python和一些依赖等，为了不让用户那么麻烦把ansible放到了容器里供用户使用。如果不想配置免密钥使用用户名密码时又需要ssh-pass等，总之不能让我满意，不是我想的极简。
所以我想就来一个二进制文件工具，没有任何依赖，文件分发与远程命令都通过调用sdk实现所以不依赖其它任何东西，总算让我这个有洁癖的人满意了。
 为什么不用keepalived haproxy
 haproxy用static pod跑没有太大问题还算好管理，keepalived现在大部分开源ansible脚本都用yum 或者apt等装，这样非常的不可控，有如下劣势：
 源不一致可能导致版本不一致，版本不一直连配置文件都不一样，我曾经检测脚本不生效一直找不到原因，后来才知道是版本原因 系统原因安装不上，依赖库问题某些环境就直接装不上了 看了网上很多安装脚本，很多检测脚本与权重调节方式都不对，直接去检测haproxy进程在不在，其实是应该去检测apiserver是不是healthz的,api挂了即使haproxy在集群也会不正常了，就是伪高可用了。 管理不方便，通过prometheus对集群进行监控，是能直接监控到static pod的但是用systemd跑又需要单独设置监控，且重启啥的还需要单独拉起。不如kubelet统一管理来的干净简洁。 我们还出现过keepalived把CPU占满的情况。  所以为了解决这个问题，我把keepalived跑在了容器中(社区提供的镜像基本是不可用的) 改造中间也是发生过很多问题，最终好在解决了。
总而言之，累觉不爱，所以在想能不能甩开haproxy和keepalived做出更简单更可靠的方案出来，还真找到了。。。
 本地负载为什么不使用envoy或者nginx
 我们通过本地负载解决高可用问题 解释一下本地负载，就是在每个node节点上都启动一个负载均衡，上游就是三个master，负载方式有很多 ipvs envoy nginx等，我们最终使用内核ipvs 如果使用envoy等需要在每个节点上都跑一个进程，消耗更多资源，这是我不希望的。ipvs实际也多跑了一个进程lvscare，但是lvscare只是负责管理ipvs规则，和kube-proxy类似，真正的流量还是从很稳定的内核走的，不需要再把包走到用户态中去处理。 实现上有个问题会让使用envoy等变得非常尴尬，就是join时如果负载均衡没有建立那是会卡住的，kubelet就不会起，所以为此你需要先把envory起起来，意味着你又不能用static pod去管理它，同上面keepalived宿主机部署一样的问题，用static pod就会相互依赖，逻辑死锁，鸡说要先有蛋，蛋说要先有鸡，最后谁都没有。  使用ipvs就不一样，我可以在join之前先把ipvs规则建立好，再去join就可以join进去了，然后对规则进行守护即可。一旦apiserver不可访问了，会自动清理掉所有node上对应的ipvs规则， master恢复正常时添加回来。
 为什么要定制kubeadm
 首先是由于kubeadm把证书时间写死了，所以需要定制把它改成99年，虽然大部分人可以自己去签个新证书，但是我们还是不想再依赖个别的工具，就直接改源码了。
其次就是做本地负载时修改kubeadm代码是最方便的，因为在join时我们需要做两个事，第一join之前先创建好ipvs规则，第二创建static pod，如果这块不去定制kubeadm就把报静态pod目录已存在的错误，忽略这个错误很不优雅。 而且kubeadm中已经提供了一些很好用的sdk供我们去实现这个功能。
且这样做之后最核心的功能都集成到kubeadm中了，sealos就单单变成分发和执行上层命令的轻量级工具了，增加节点时我们也就可以直接用kubeadm了
使用教程 安装依赖  安装并启动docker 下载kubernetes 离线安装包.</description>
    </item>
    
    <item>
      <title>k8s高可用一个kubeadm搞定,无依赖keepalived haproxy ansible</title>
      <link>https://sealyun.com/blog/2019/04/01/super-kubeadm/</link>
      <pubDate>Mon, 01 Apr 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/04/01/super-kubeadm/</guid>
      <description>&lt;p&gt;探讨可加QQ群：98488045&lt;/p&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;地址&lt;a href=&#34;https://github.com/fanux/sealos&#34;&gt;sealos&lt;/a&gt;, 让kubernetes高可用不再需要keepalived haproxy和ansible,&lt;/p&gt;

&lt;p&gt;sealyun定制超级版kubeadm通过ipvs代理多个master，优雅解决k8s高可用问题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>tektoncd pipeline教程 - kubernetes原生pipeline</title>
      <link>https://sealyun.com/blog/2019/03/27/tektoncd-pipeline/</link>
      <pubDate>Wed, 27 Mar 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/03/27/tektoncd-pipeline/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概览&#34;&gt;概览&lt;/h1&gt;

&lt;p&gt;Tekton Pipeline,是一个k8s native的pipeline, 任务跑在pod中，通过自定义CRD去管理任务与工作流等等，我看完tekton之后感觉是功能很强大，但是有点过度设计了，没有drone的简约大方灵活之感&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于overlay2存储驱动的磁盘配额问题</title>
      <link>https://sealyun.com/blog/2019/03/23/docker-oerlay2/</link>
      <pubDate>Sat, 23 Mar 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/03/23/docker-oerlay2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;这篇短文向大家介绍一下正确使用存储驱动的姿势，非常有用。&lt;/p&gt;

&lt;h2 id=&#34;为啥要用overlay2&#34;&gt;为啥要用overlay2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;docker centos（内核3.10）上默认存储驱动是devicemapper 的loop-lvm模式，这种模式是用文件模拟块设备，不推荐生产使用&lt;/li&gt;
&lt;li&gt;direct lvm又不是一个开箱即用的模式，懒得配置&lt;/li&gt;
&lt;li&gt;最关键的是 docker in docker的情况下 device mapper是行不通的，典型的场景就是用drone时，构建docker镜像就不能正常工作&lt;/li&gt;
&lt;li&gt;overlay存储驱动层数过多时会导致文件链接数过多可能会耗尽inode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以当前overlay2是个比较好的选择&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>containerd与kubernetes集成</title>
      <link>https://sealyun.com/blog/2019/03/11/containerd/</link>
      <pubDate>Mon, 11 Mar 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/03/11/containerd/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;概念介绍&#34;&gt;概念介绍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;cri (Container runtime interface)

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cri&lt;/code&gt; is a &lt;a href=&#34;https://containerd.io/&#34;&gt;containerd&lt;/a&gt; plugin implementation of Kubernetes &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/apis/cri/runtime/v1alpha2/api.proto&#34;&gt;container runtime interface (CRI)&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;cri是 kubernetes的容器运行时接口的容器插件实现。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>kubernetes 用户token教程</title>
      <link>https://sealyun.com/blog/2019/02/20/user-token/</link>
      <pubDate>Wed, 20 Feb 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/02/20/user-token/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;kubernetes server account的token很容易获取，但是User的token非常麻烦，本文给出一个极简的User token生成方式，让用户可以一个http请求就能获取到。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>属于极客的k8s管理工具fist, 强大的webterminal</title>
      <link>https://sealyun.com/blog/2019/02/05/fist-terminal/</link>
      <pubDate>Tue, 05 Feb 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/02/05/fist-terminal/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fanux/fist&#34;&gt;fist&lt;/a&gt;是sealyun开发的精致的k8s管理工具，所有功能切入要害，而不追求多与重，接下来的介绍我相信有节操的k8s管理员一定会喜欢它。&lt;/p&gt;

&lt;h1 id=&#34;terminal功能安装&#34;&gt;terminal功能安装&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fanux/fist/blob/master/terminal/README.md&#34;&gt;安装地址&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;集成kubectl&#34;&gt;集成kubectl&lt;/h1&gt;

&lt;p&gt;terminal中可直接使用kubectl，用户就不需要登录到机器上或者自己装kubectl远程访问集群，当然这是基本功能&lt;/p&gt;

&lt;h1 id=&#34;自动渲染kubeconfig文件&#34;&gt;自动渲染kubeconfig文件&lt;/h1&gt;

&lt;p&gt;会根据传入的token去创建.kube/config 文件，如何给用户创建token &lt;a href=&#34;https://github.com/fanux/fist#auth&#34;&gt;看这里&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>rook使用教程，快速编排ceph</title>
      <link>https://sealyun.com/blog/2019/01/23/rook/</link>
      <pubDate>Wed, 23 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/23/rook/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文中需要用的yaml文件和Dockerfile等都放到这个&lt;a href=&#34;https://github.com/sealyun/rook&#34;&gt;仓库&lt;/a&gt;
包含：rook operator ceph cluster storage class配置，mysql wordpress事例，性能测试fio Dockerfile与yaml等&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>基于Envoy的Ingress controller使用介绍</title>
      <link>https://sealyun.com/blog/2019/01/23/envoy-ingress/</link>
      <pubDate>Wed, 23 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/23/envoy-ingress/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;ingress controller有很多，这里介绍其中一个&lt;a href=&#34;https://github.com/heptio/contour&#34;&gt;contour&lt;/a&gt;, 我没有使用ingress controller的原因是&lt;/p&gt;

&lt;p&gt;首先contour的实现是envoy, 其动态配置能力强于nginx，其次可以非常方便的对接监控系统，也是istio的核心组件。 本文其实还是以ingress的用法
为主, 因为不管是什么实现都兼容ingress的配置标准&lt;/p&gt;

&lt;p&gt;还有就是contour是唯一实现了自定义IngressRoute CRD来实现更复杂的路由功能，websocket支持，健康检测，prefix rewite支持,还有TCP代理&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>是时候表现一下我的vim了</title>
      <link>https://sealyun.com/blog/2019/01/23/vim/</link>
      <pubDate>Wed, 23 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/23/vim/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;
探讨可加QQ群：98488045&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;使用vim作golang开发&#34;&gt;使用vim作golang开发&lt;/h1&gt;

&lt;p&gt;分享一些我使用的vim插件，以及制作过程，最终的功能有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;golang开发，补全，跳转，文件列表，函数列表等&lt;/li&gt;
&lt;li&gt;kubernetes插件，方便写yaml文件&lt;/li&gt;
&lt;li&gt;好看的颜色主题&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>keepalived in docker</title>
      <link>https://sealyun.com/blog/2019/01/10/keepalived/</link>
      <pubDate>Thu, 10 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/10/keepalived/</guid>
      <description>&lt;h1 id=&#34;kubernetes集群三步安装-https-sealyun-com-pro-products&#34;&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;目前keepalived作为kubernetes集群高可用的重要组件，保障虚拟ip可以在多个主机间漂移，&lt;a href=&#34;https://github.com/fanux/sealos&#34;&gt;sealos&lt;/a&gt; 也是使用了，只是在方案上与传统的方式有很大区别&lt;/p&gt;

&lt;p&gt;首先把keepalived放到容器里了，版本也用了比较新的2.x.x以上&lt;/p&gt;

&lt;p&gt;然后使用kubernetes static pod去管理keepalived服务&lt;/p&gt;

&lt;h1 id=&#34;keepalived放到容器里的好处&#34;&gt;keepalived放到容器里的好处&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;安装成功率更高，更跨平台, 传统方式如用yum安装或者其它，如果采用那些办法在别的一些发型版系统上sealos就不可用。其次，很多系统的源不一样导致版本不一致造成问题，如果通过源码编译可能一些系统库版本直接导致编译不通过，所以为了提高高可用的安装成功率，放容器里是最好的方式&lt;/li&gt;
&lt;li&gt;无需额外对keepalived增加监控, 因为是pod，而sealos又已经集成了prometheus，所以不需要再额外添加监控信息&lt;/li&gt;
&lt;li&gt;统一管理, keepalived异常退出什么的kubelet也会将其拉起，与其它的kubernetes组件就有了一个统一的方式管理&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>关于sealyun营销系统</title>
      <link>https://sealyun.com/blog/2019/01/06/referrer/</link>
      <pubDate>Sun, 06 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/06/referrer/</guid>
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;任何用户都可以通过sealyun赚钱，很方便的获取到一个分享链接，如果别的用户是通过你的分享链接购买商品的那么您将获得一笔不错的提成，目前是交易金额的60%，&lt;/p&gt;

&lt;p&gt;也就是如商品50元，别的用户通过您的链接购买成功，您可获得30元，平台获得20元&lt;/p&gt;

&lt;h1 id=&#34;操作步骤&#34;&gt;操作步骤&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;获取营销链接 &lt;a href=&#34;http://store.lameleg.com/&#34;&gt;网站地址http://store.lameleg.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>使用prometheus operator监控envoy</title>
      <link>https://sealyun.com/blog/2019/01/01/prometheus-operator-envoy/</link>
      <pubDate>Tue, 01 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/01/prometheus-operator-envoy/</guid>
      <description>&lt;h1 id=&#34;kubernetes集群三步安装-https-sealyun-com-pro-products&#34;&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;prometheus operator应当是使用监控系统的最佳实践了，首先它一键构建整个监控系统，通过一些无侵入的手段去配置如监控数据源等
故障自动恢复，高可用的告警等。。&lt;/p&gt;

&lt;p&gt;不过对于新手使用上还是有一丢丢小门槛，本文就结合如何给envoy做监控这个例子来分享使用prometheus operator的正确姿势&lt;/p&gt;

&lt;p&gt;至于如何写告警规则，如何配置prometheus查询语句不是本文探讨的重点，会在后续文章中给大家分享，本文着重探讨如何使用prometheus operator&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kube-scheduler定制，支持深度学习批处理任务调度</title>
      <link>https://sealyun.com/blog/2018/12/25/kube-batch/</link>
      <pubDate>Tue, 25 Dec 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/12/25/kube-batch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;什么是批处理任务&#34;&gt;什么是批处理任务&lt;/h1&gt;

&lt;p&gt;深度学习中经常会出现多机多卡的任务，也就是同事会起多个pod，但是这多个pod属于同一个任务。&lt;/p&gt;

&lt;p&gt;这样就会有一个问题&lt;/p&gt;

&lt;p&gt;一个任务要起100个pod，每个pod需要一张卡，总共需要100张GPU卡，而集群中只有99张空闲的GPU卡，这样默认的k8s调度器会如何处理？&lt;/p&gt;

&lt;p&gt;因为默认调度器是一个一个pod调度的，只会检查单个pod资源够不够，这样前99个都能成功，最后一个pod调度失败。&lt;/p&gt;

&lt;p&gt;这样非常有可能造成&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;任务跑不了&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;前99个占着GPU不释放，新的任务无法调度&lt;/li&gt;
&lt;li&gt;严重时整个集群死锁，都“占着茅坑不拉屎”&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>sealyun kubernetes离线包文档</title>
      <link>https://sealyun.com/blog/2018/12/11/docs/</link>
      <pubDate>Tue, 11 Dec 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/12/11/docs/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://store.lameleg.com/&#34;&gt;kubernetes安装包store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://store.lameleg.com/&#34;&gt;官方销售市场&lt;/a&gt;：&lt;a href=&#34;http://store.lameleg.com/&#34;&gt;http://store.lameleg.com/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;阿里云市场购买下载地址列表&lt;/a&gt;：&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;https://sealyun.com/pro/products/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;商品介绍&#34;&gt;商品介绍&lt;/h1&gt;

&lt;p&gt;安装包通过kubeadm安装kubernetes集群,包含：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;核心基础组件 etcd apisver kubelet kube-proxy scheduler manager&lt;/li&gt;
&lt;li&gt;addon组件    dashboard calico promethus grafana alertmanager node-exporter coreDNS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启用IPVS&lt;/p&gt;

&lt;p&gt;可以内网环境进行安装，但是不包含docker&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubeadm杂谈</title>
      <link>https://sealyun.com/blog/2018/12/04/kubeadm/</link>
      <pubDate>Tue, 04 Dec 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/12/04/kubeadm/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;kubeadm-1-13版本&#34;&gt;kubeadm 1.13版本&lt;/h1&gt;

&lt;p&gt;此版本更新了不少东西，以前老的配置不再适用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;W1205 19:10:23.541054   58540 strict.go:54] error unmarshaling configuration schema.GroupVersionKind{Group:&amp;quot;kubeadm.k8s.io&amp;quot;, Version:&amp;quot;v1beta1&amp;quot;, Kind:&amp;quot;InitConfiguration&amp;quot;}: error unmarshaling JSON: while decoding JSON: json: unknown field

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>修改kubeadm证书过期时间</title>
      <link>https://sealyun.com/blog/2018/11/07/kubeadm-dev/</link>
      <pubDate>Wed, 07 Nov 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/11/07/kubeadm-dev/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;修改kubeadm证书过期时间&#34;&gt;修改kubeadm证书过期时间&lt;/h1&gt;

&lt;p&gt;本文通过修改kubeadm源码让kubeadm默认的一年证书过期时间修改为99年&lt;/p&gt;

&lt;p&gt;我已经编译好了一个放在了&lt;a href=&#34;https://github.com/fanux/sealos/releases/tag/kubeadm1.12.2&#34;&gt;github&lt;/a&gt;上，有需要的可以直接下&lt;/p&gt;

&lt;p&gt;使用方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@dev-86-202 ~]# chmod +x kubeadm &amp;amp;&amp;amp; cp kubeadm /usr/bin
[root@dev-86-202 ~]# rm /etc/kubernetes/pki/ -rf
[root@dev-86-202 ~]# kubeadm alpha phase certs all --config  kube/conf/kubeadm.yaml
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>kubernetes源码分析之kube-scheduler - 从代码看原理</title>
      <link>https://sealyun.com/blog/2018/11/06/kube-scheduler-source-code/</link>
      <pubDate>Tue, 06 Nov 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/11/06/kube-scheduler-source-code/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;kube-scheduler源码分析&#34;&gt;kube-scheduler源码分析&lt;/h1&gt;

&lt;h2 id=&#34;关于源码编译&#34;&gt;关于源码编译&lt;/h2&gt;

&lt;p&gt;我嫌弃官方提供的编译脚本太麻烦，所以用了更简单粗暴的方式编译k8s代码，当然官方脚本在编译所有项目或者夸平台编译以及realse时还是挺有用的。&lt;/p&gt;

&lt;p&gt;在容器中编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -v /work/src/k8s.io/kubernetes:/go/src/k8s.io/kubernetes golang:1.11.2 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在容器中可以保证环境干净&lt;/p&gt;

&lt;p&gt;进入bash后直接进入kube-scheduler的主目录编译即可&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>构建生产环境可用的高可用kubernetes集群</title>
      <link>https://sealyun.com/blog/2018/10/24/sealos/</link>
      <pubDate>Wed, 24 Oct 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/10/24/sealos/</guid>
      <description>&lt;h1 id=&#34;kubernetes集群三步安装-https-sealyun-com-pro-products&#34;&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;k8s-1-14以上版本请直接参考-sealos-readme-https-github-com-fanux-sealos&#34;&gt;k8s 1.14以上版本请直接参考&lt;a href=&#34;https://github.com/fanux/sealos&#34;&gt;sealos readme&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;sealos是一个轻量级kubernetes HA安装项目，重点关注功能的收敛而非庞大复杂厚重，旨在容易定制。除kubelet意外其它任何组件均在容器中运行
这样做的好处有几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保证一致性，这样避免掉很多因宿主环境问题导致的安装失败，如keepalived版本问题，系统库问题等等&lt;/li&gt;
&lt;li&gt;统一管理统一监控，这样我们就不需要为如keepalived etcd haproxy单独配置进程级别的监控，仅要监控pod即可，kubelet也会对这些容器做比较好的管理，如自动拉起等&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>基于drone构建CI/CD系统,对接k8s</title>
      <link>https://sealyun.com/blog/2018/10/10/ci-cd/</link>
      <pubDate>Wed, 10 Oct 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/10/10/ci-cd/</guid>
      <description>&lt;h1 id=&#34;kubernetes集群三步安装-https-sealyun-com-pro-products&#34;&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;ci-概述&#34;&gt;CI 概述&lt;/h1&gt;

&lt;h3 id=&#34;用一个可描述的配置定义整个工作流&#34;&gt;用一个可描述的配置定义整个工作流&lt;/h3&gt;

&lt;p&gt;程序员是很懒的动物，所以想各种办法解决重复劳动的问题，如果你的工作流中还在重复一些事，那么可能就得想想如何优化了&lt;/p&gt;

&lt;p&gt;持续集成就是可以帮助我们解决重复的代码构建，自动化测试，发布等重复劳动，通过简单一个提交代码的动作，解决接下来要做的很多事。&lt;/p&gt;

&lt;p&gt;容器技术使这一切变得更完美。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>etcd管理指南</title>
      <link>https://sealyun.com/blog/2018/08/12/etcd-manage/</link>
      <pubDate>Sun, 12 Aug 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/08/12/etcd-manage/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;广告 | &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;kubernetes各版本离线安装包&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;etcd-证书配置&#34;&gt;etcd 证书配置&lt;/h1&gt;

&lt;p&gt;生产环境中给etcd配置证书相当重要，如果没有证书，那么k8s集群很容易被黑客利用而去挖矿什么的。做法非常简单，比如你下了一个不安全的镜像，通过程序扫描到etcd的ip和端口，那么黑客就可以绕开apiserver的认证直接写数据，写一些deployment pod等等，apiserver就会读到这些，从而去部署黑客的程序。 我们就有一个集群这样被利用去挖矿了,安全无小事，如果黑客恶意攻击也可轻松删除你的所有数据，所以证书与定期备份都很重要,即便有多个etcd节点，本文深入探讨etcd管理的重要的几个东西。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes dashboard监控数据无法正常显示</title>
      <link>https://sealyun.com/blog/2018/08/10/heapster-error/</link>
      <pubDate>Fri, 10 Aug 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/08/10/heapster-error/</guid>
      <description>&lt;h1 id=&#34;kubernetes集群三步安装-https-sealyun-com-pro-products&#34;&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;kubernetes1-12-0版本dashboard使用heapster无法正常显示监控数据&#34;&gt;kubernetes1.12.0版本dashboard使用heapster无法正常显示监控数据&lt;/h1&gt;

&lt;p&gt;查看heapster日志：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E0228 20:01:05.019281       1 manager.go:101] Error in scraping containers from kubelet:30.0.1.4:10255: failed to get all container stats from Kubelet URL &amp;quot;http://30.0.1.4:10255/stats/container/&amp;quot;: Post http://30.0.1.4:10255/stats/container/: dial tcp 30.0.1.4:10255: getsockopt: connection refused
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>istio安装使用教程</title>
      <link>https://sealyun.com/blog/2018/07/30/istio-quickstart/</link>
      <pubDate>Mon, 30 Jul 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/07/30/istio-quickstart/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;广告 | &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;kubernetes各版本离线安装包&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;祝贺istio1.0发布, 在此献上教程一份&lt;/p&gt;

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;安装k8s &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;强势插播广告&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;三步安装，不多说&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;安装helm, 推荐生产环境用helm安装，可以调参&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>kubernetes开发指南</title>
      <link>https://sealyun.com/blog/2018/06/21/kube-dev/</link>
      <pubDate>Thu, 21 Jun 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/06/21/kube-dev/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;广告 | &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;kubernetes离线安装包，仅需三步&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;官方例子&#34;&gt;官方例子&lt;/h2&gt;

&lt;p&gt;大部分使用方式调用clientgo即可，我增加一些clientgo事例里没有的一些技巧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/client-go/tree/master/examples&#34;&gt;clientgo 事例地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;初始化客户端&#34;&gt;初始化客户端&lt;/h2&gt;

&lt;p&gt;这里给了两种初始化kubernetes客户端的方式，一种根据kubeconfig文件的路径，官方有，比较简单&lt;/p&gt;

&lt;p&gt;另一种就是根据kubeconfig内容的字符串去初始化一个客户端，这种方式应用场景是比如我们把很多的kubeconfig文件存在了数据库中（多租户时）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kube-proxy源码解析</title>
      <link>https://sealyun.com/blog/2018/06/20/kube-proxy-src/</link>
      <pubDate>Wed, 20 Jun 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/06/20/kube-proxy-src/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;广告 | &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;kubernetes离线安装包，仅需三步&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;kube-proxy源码解析&#34;&gt;kube-proxy源码解析&lt;/h1&gt;

&lt;p&gt;ipvs相对于iptables模式具备较高的性能与稳定性, 本文讲以此模式的源码解析为主，如果想去了解iptables模式的原理，可以去参考其实现，架构上无差别。&lt;/p&gt;

&lt;p&gt;kube-proxy主要功能是监听service和endpoint的事件，然后下放代理策略到机器上。 底层调用&lt;a href=&#34;https://github.com/docker/libnetwork&#34;&gt;docker/libnetwork&lt;/a&gt;, 而libnetwork最终调用了&lt;a href=&#34;https://github.com/vishvananda/netlink&#34;&gt;netlink&lt;/a&gt; 与netns来实现ipvs的创建等动作&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes启用ipvs</title>
      <link>https://sealyun.com/blog/2018/05/29/k8s-ipvs/</link>
      <pubDate>Tue, 29 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/05/29/k8s-ipvs/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;广告 | &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;kubernetes各版本离线安装包&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-11-1版本已经修复此bug-如在centos下使用ipvs模式建议升级到-v1-11-1-包地址-http-sealyun-com-pro-products&#34;&gt;1.11.1版本已经修复此bug，如在centos下使用ipvs模式建议升级到&lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;v1.11.1,包地址&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;1-11-0版本ipset-bug说明&#34;&gt;1.11.0版本ipset bug说明&lt;/h1&gt;

&lt;p&gt;1.11.0版本centos下使用ipvs模式会出问题 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/65461&#34;&gt;65461&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Jun 25 20:50:00 VM_3_4_centos kube-proxy[3828]: E0625 20:50:00.312569    3828 ipset.go:156] Failed to make sure ip set: &amp;amp;{{KUBE-LOOP-BACK hash:ip,port,ip inet 1024 65536 0-65535 Kubernetes endpoints dst ip:port, source ip for solving hairpin purpose} map[] 0xc42073e1d0} exist, error: error creating ipset KUBE-LOOP-BACK, error: exit status 2
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>kubeadm源码分析</title>
      <link>https://sealyun.com/blog/2018/05/11/kubeadm-source/</link>
      <pubDate>Fri, 11 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/05/11/kubeadm-source/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;k8s离线安装包&lt;/a&gt; 三步安装，简单到难以置信&lt;/p&gt;

&lt;h1 id=&#34;kubeadm源码分析&#34;&gt;kubeadm源码分析&lt;/h1&gt;

&lt;p&gt;说句实在话，kubeadm的代码写的真心一般，质量不是很高。&lt;/p&gt;

&lt;p&gt;几个关键点来先说一下kubeadm干的几个核心的事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kubeadm 生成证书在/etc/kubernetes/pki目录下&lt;/li&gt;
&lt;li&gt;kubeadm 生成static pod yaml配置，全部在/etc/kubernetes/manifasts下&lt;/li&gt;
&lt;li&gt;kubeadm 生成kubelet配置，kubectl配置等 在/etc/kubernetes下&lt;/li&gt;
&lt;li&gt;kubeadm 通过client go去启动dns&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>kubernetes RBAC实战</title>
      <link>https://sealyun.com/blog/2018/05/11/k8s-rbac/</link>
      <pubDate>Fri, 11 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/05/11/k8s-rbac/</guid>
      <description>&lt;h2 id=&#34;kubernetes-rbac实战&#34;&gt;kubernetes RBAC实战&lt;/h2&gt;

&lt;h2 id=&#34;环境准备&#34;&gt;环境准备&lt;/h2&gt;

&lt;p&gt;先用kubeadm安装好kubernetes集群，&lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;包地址在此&lt;/a&gt; 好用又方便，服务周到，童叟无欺&lt;/p&gt;

&lt;p&gt;本文目的，让名为devuser的用户只能有权限访问特定namespace下的pod&lt;/p&gt;

&lt;h2 id=&#34;命令行kubectl访问&#34;&gt;命令行kubectl访问&lt;/h2&gt;

&lt;h3 id=&#34;安装cfssl&#34;&gt;安装cfssl&lt;/h3&gt;

&lt;p&gt;此工具生成证书非常方便, pem证书与crt证书,编码一致可直接使用&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes对接第三方认证</title>
      <link>https://sealyun.com/blog/2018/05/11/k8s-authenticating/</link>
      <pubDate>Fri, 11 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/05/11/k8s-authenticating/</guid>
      <description>&lt;h1 id=&#34;kubernetes对接第三方认证&#34;&gt;kubernetes对接第三方认证&lt;/h1&gt;

&lt;p&gt;广告： &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;安装包地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;本文介绍如何使用github账户去关联自己kubernetes账户。达到如下效果：
1. 使用github用户email作为kubernetes用户，如fhtjob@hotmail.com
2. 创建对应的clusterrole绑定给fhtjob@hotmail.com这个用户
3. 给fhtjob@hotmail这个用户创建一个kubeconfig文件，让改用户可以使用kubectl命令操作集群，且只有部分权限&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes高可用相关配置</title>
      <link>https://sealyun.com/blog/2018/05/11/k8s-ha-conf/</link>
      <pubDate>Fri, 11 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/05/11/k8s-ha-conf/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/setup/independent/high-availability/&#34;&gt;kubeadm HA教程&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;机器&#34;&gt;机器&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10.100.81.11&lt;/td&gt;
&lt;td&gt;master、etcd&lt;/td&gt;
&lt;td&gt;主节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.12&lt;/td&gt;
&lt;td&gt;master、etcd、keepalived、haproxy&lt;/td&gt;
&lt;td&gt;主节点，同时部署keepalived、haproxy，保证master高可用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.13&lt;/td&gt;
&lt;td&gt;master、etcd、keepalived、haproxy&lt;/td&gt;
&lt;td&gt;主节点，同时部署keepalived、haproxy，保证master高可用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.14&lt;/td&gt;
&lt;td&gt;node、etcd&lt;/td&gt;
&lt;td&gt;非业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.15&lt;/td&gt;
&lt;td&gt;node、etcd&lt;/td&gt;
&lt;td&gt;非业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.16&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.17&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.18&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.19&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.20&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.21&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.22&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.23&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.24&lt;/td&gt;
&lt;td&gt;node、harbor&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.25&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;组件版本&#34;&gt;组件版本&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>k8s离线包解析</title>
      <link>https://sealyun.com/blog/2018/04/24/sealyun-k8s-offline/</link>
      <pubDate>Tue, 24 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/04/24/sealyun-k8s-offline/</guid>
      <description>&lt;h1 id=&#34;k8s离线包解析&#34;&gt;k8s离线包解析&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;产品地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;鸣谢&#34;&gt;鸣谢&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;大家好，首先感谢大家对我们产品的支持，特别是一些老客户的持续支持，让我可以有动力把这个事情持续进行下去。&lt;/li&gt;
&lt;li&gt;感谢大家对付费产品的认可，尊重付费&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;产品介绍&#34;&gt;产品介绍&lt;/h2&gt;

&lt;p&gt;我们专注于k8s离线包的制作，优化细节，让大家可以很方便快速的安装k8s集群。
下面详细介绍安装包的原理以及如何去制作一个这样的包，大家参考我的方法也可以制作自己想要的版本然后用于自己的离线环境&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker架构分析</title>
      <link>https://sealyun.com/blog/2017/07/11/docker-architech/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/docker-architech/</guid>
      <description>&lt;h2 id=&#34;docker架构分析&#34;&gt;Docker架构分析&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[root@docker-build-86-050 ~]# ls /usr/bin |grep docker
docker
docker-compose
docker-containerd
docker-containerd-ctr
docker-containerd-shim
dockerd
docker-proxy
docker-runc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家一定很困惑 dockerd, containerd, ctr,shim, runc,等这几个进程的关系到底是啥&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>calico 网络原理</title>
      <link>https://sealyun.com/blog/2017/07/11/calico/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/calico/</guid>
      <description>&lt;h1 id=&#34;calico-网络原理&#34;&gt;calico 网络原理&lt;/h1&gt;

&lt;h3 id=&#34;node节点-装网络之前路由&#34;&gt;node节点 装网络之前路由&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[root@iZj6c3cqwumhn5jov661z7Z ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.31.255.253  0.0.0.0         UG    0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
172.31.240.0    0.0.0.0         255.255.240.0   U     0      0        0 eth0
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>calico架构</title>
      <link>https://sealyun.com/blog/2017/07/11/calico-architecture/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/calico-architecture/</guid>
      <description>&lt;h2 id=&#34;安装常见问题&#34;&gt;安装常见问题&lt;/h2&gt;

&lt;p&gt;calico无法启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Readiness probe failed: calico/node is not ready: felix is not ready: Get http://localhost:9099/readiness: dial tcp [::1]:9099: connect: connection refused 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很可能是网卡发现有问题，calico虚拟化时没找对网卡，calico会经常找docker0网桥，导致clusterIP不通从而calico node连不上etcd&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>calico网络策略</title>
      <link>https://sealyun.com/blog/2017/07/11/calico-network-policy/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/calico-network-policy/</guid>
      <description>&lt;h2 id=&#34;calico网络策略&#34;&gt;calico网络策略&lt;/h2&gt;

&lt;p&gt;使用kubernetes NetworkPolicy让用户定义pod之间的访问策略，精细的控制哪些pod之间有相互访问的权利，如此网络更安全.&lt;/p&gt;

&lt;h2 id=&#34;教程流程&#34;&gt;教程流程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;创建nginx service&lt;/li&gt;
&lt;li&gt;禁止所有入口流量&lt;/li&gt;
&lt;li&gt;允许向内访问nginx&lt;/li&gt;
&lt;li&gt;禁止所有出口流程&lt;/li&gt;
&lt;li&gt;允许出口流量访问kube-dns&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>kubernetes安装</title>
      <link>https://sealyun.com/blog/2017/07/11/install-k8s/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/install-k8s/</guid>
      <description>&lt;p&gt;alico node &amp;lsquo;iZ2ze3nu0s9j3v57be4xuuZ&amp;rsquo; is already using the IPv4 address 192.168.152.65&lt;/p&gt;

&lt;h3 id=&#34;基础环境&#34;&gt;基础环境&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;关闭防火墙 selinux&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$ systemctl stop firewalld &amp;amp;&amp;amp; systemctl disable firewalld
$ setenforce 0
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;打开forward
sysctl -w net.ipv4.ip_forward=1&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>容器信号使用</title>
      <link>https://sealyun.com/blog/2017/07/11/container-stop-timeout/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/container-stop-timeout/</guid>
      <description>&lt;h2 id=&#34;容器信号使用&#34;&gt;容器信号使用&lt;/h2&gt;

&lt;p&gt;我们跑在容器中的程序通常想在容器退出之前做一些清理操作，比较常用的方式是监听一个信号，延迟关闭容器。&lt;/p&gt;

&lt;p&gt;docker提供了这样的功能：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;╰─➤  docker stop --help

Usage:  docker stop [OPTIONS] CONTAINER [CONTAINER...]

Stop one or more running containers

Options:
      --help       Print usage
  -t, --time int   Seconds to wait for stop before killing it (default 10)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>docker开发流程</title>
      <link>https://sealyun.com/blog/2016/07/11/docker-dev/</link>
      <pubDate>Mon, 11 Jul 2016 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2016/07/11/docker-dev/</guid>
      <description>&lt;h2 id=&#34;docker开发流程&#34;&gt;docker开发流程&lt;/h2&gt;

&lt;p&gt;注意容器构建时的信息：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ovs对接容器网络</title>
      <link>https://sealyun.com/blog/2016/07/11/docker-ovs/</link>
      <pubDate>Mon, 11 Jul 2016 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2016/07/11/docker-ovs/</guid>
      <description>&lt;h1 id=&#34;初始化环境&#34;&gt;初始化环境&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;升级内核：
      rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
      rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm
      yum --enablerepo=elrepo-kernel install  kernel-ml-devel kernel-ml
      awk -F\&#39; &#39;$1==&amp;quot;menuentry &amp;quot; {print $2}&#39; /etc/grub2.cfg
      grub2-set-default 0
      reboot
      uname -a

安装docker:
     yum install -y yum-utils
     yum-config-manager     --add-repo     https://download.docker.com/linux/centos/docker-ce.repo
     yum-config-manager --disable docker-ce-edge
     yum makecache fast
     yum install docker-ce
     service docker start


安装open vswitch:
     yum -y install wget openssl-devel gcc make python-devel openssl-devel kernel-devel graphviz kernel-debug-devel autoconf automake rpm-build redhat-rpm-config libtool python-twisted-core python-zope-interface PyQt4 desktop-file-utils libcap-ng-devel groff checkpolicy selinux-policy-devel
     adduser ovs
     su - ovs
     yum localinstall /home/ovs/rpmbuild/RPMS/x86_64/openvswitch-2.5.0-1.el7.centos.x86_64.rpm -y
     systemctl start openvswitch.service
     systemctl is-active openvswitch
     ovs-vsctl -V
     systemctl enable openvswitch

安装pipework:
     yum install git
     git clone https://github.com/jpetazzo/pipework
     cp pipework/pipework /bin
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>容器网络概述</title>
      <link>https://sealyun.com/blog/2016/07/11/docker-network/</link>
      <pubDate>Mon, 11 Jul 2016 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2016/07/11/docker-network/</guid>
      <description>&lt;h2 id=&#34;网络概述&#34;&gt;网络概述&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;端口映射：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -p 8080:80 nginx:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有这个-p，会发现启动了nginx但是无法通过宿主机访问到web服务，而使用了-p参数后就可以通过访问主机的8080断开去访问nginx了。
端口映射的原理是作了net转发&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;共享主机网络:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --net=host nginx:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种容器没有自己的网络，完全共享主机的网络，所以可以通过主机ip直接访问容器服务。 坏处是容器与其它容器端口冲突&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>iptables教程</title>
      <link>https://sealyun.com/blog/2016/05/11/iptables/</link>
      <pubDate>Wed, 11 May 2016 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2016/05/11/iptables/</guid>
      <description>&lt;h1 id=&#34;iptables教程&#34;&gt;iptables教程&lt;/h1&gt;

&lt;h2 id=&#34;内核空间中的五个包处理位置-和五个函数钩子-规则链&#34;&gt;内核空间中的五个包处理位置，和五个函数钩子（规则链）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PREROUTING 数据包刚进入网络层 , 路由之前&lt;/li&gt;
&lt;li&gt;INPUT 路由判断，流入用户空间&lt;/li&gt;
&lt;li&gt;OUTPUT 用户空间发出，后接路由判断出口的网络接口&lt;/li&gt;
&lt;li&gt;FORWARD 路由判断不进入用户空间，只进行转发&lt;/li&gt;
&lt;li&gt;POSTROUTING 数据包通过网络接口出去&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>golang基于protobuf的rpc使用</title>
      <link>https://sealyun.com/blog/2015/07/11/rpc-protobuf/</link>
      <pubDate>Sat, 11 Jul 2015 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2015/07/11/rpc-protobuf/</guid>
      <description>&lt;h2 id=&#34;golang基于protobuf的rpc使用&#34;&gt;golang基于protobuf的rpc使用&lt;/h2&gt;

&lt;p&gt;基本安装什么的在此不再赘述，不知道的看&lt;a href=&#34;http://www.grpc.io/docs/quickstart/go.html&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;proto文件&#34;&gt;proto文件&lt;/h3&gt;

&lt;p&gt;cat helloworld.proto&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>dns之锅TODO</title>
      <link>https://sealyun.com/blog/2014/07/11/kubernetes-dns/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/kubernetes-dns/</guid>
      <description>&lt;h2 id=&#34;dns之锅&#34;&gt;dns之锅&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;kubectl run --namespace=kube-system access -it --image busybox -- /bin/sh
[root@fortest1513671663-master-00 ~]# kubectl exec access-79f4758b79-qwl8s nslookup kubernetes-dashboard.kube-system.svc -n kube-system
Server:    10.96.0.10
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes-dashboard.kube-system.svc
Address 1: 10.110.146.248 kubernetes-dashboard.kube-system.svc.cluster.local
[root@fortest1513671663-master-00 ~]# kubectl get svc kubernetes-dashboard -n kube-system
NAME                   TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE
kubernetes-dashboard   NodePort   10.110.146.248   &amp;lt;none&amp;gt;        443:30089/TCP   27m
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>grafana配置教程</title>
      <link>https://sealyun.com/blog/2014/07/11/grafana-promethus/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/grafana-promethus/</guid>
      <description>&lt;h1 id=&#34;grafana配置教程&#34;&gt;grafana配置教程&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../images/grafana/grafana.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>runc 架构破析</title>
      <link>https://sealyun.com/blog/2014/07/11/runc/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/runc/</guid>
      <description>&lt;h2 id=&#34;runc-架构破析&#34;&gt;runc 架构破析&lt;/h2&gt;

&lt;p&gt;这里的spec.Process就是我们真正要运行的容器中的进程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return r.run(&amp;amp;spec.Process)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把这个塞到libcontainer.Process里去了：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何让docker镜像尽可能小</title>
      <link>https://sealyun.com/blog/2014/07/11/scratch/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/scratch/</guid>
      <description>&lt;h1 id=&#34;如何让镜像尽可能小&#34;&gt;如何让镜像尽可能小&lt;/h1&gt;

&lt;p&gt;很容器想到from scratch, 就是没任何基础镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM scratch
COPY p /
ENTRYPOINT [&amp;quot;/p&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>安装包列表</title>
      <link>https://sealyun.com/blog/2014/07/11/offline-install/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/offline-install/</guid>
      <description>&lt;h1 id=&#34;安装包列表&#34;&gt;安装包列表&lt;/h1&gt;

&lt;h2 id=&#34;kubernetes1-10-3离线安装包-审核中&#34;&gt;[kubernetes1.10.3离线安装包 审核中]()&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;全部使用当前最新版本组建&lt;/li&gt;
&lt;li&gt;Cgroup driver自动检测，99%以上一键安装成功，遇到任何问题远程协助解决&lt;/li&gt;
&lt;li&gt;优化dashboard grafana等yaml配置&lt;/li&gt;
&lt;li&gt;DNS双副本高可用&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>离线使用kubeadm安装安全高可用kubernetes集群</title>
      <link>https://sealyun.com/blog/2014/07/11/k8s-offline-install-ha/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/k8s-offline-install-ha/</guid>
      <description>&lt;h1 id=&#34;使用kubeadm安装安全高可用kubernetes集群&#34;&gt;使用kubeadm安装安全高可用kubernetes集群&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://market.aliyun.com/products/57742013/cmxz025618.html?spm=5176.730005.0.0.TFKV5K#sku=yuncode1961800000&#34;&gt;安装包地址&lt;/a&gt; 如非高可用安装请忽略此教程，直接看产品页的三步安装。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;单个master流程：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;解压后在master 上 cd shell  &amp;amp;&amp;amp; sh init.sh ,然后sh master.sh（注意因为脚本用的相对路径所以不再当前目录会找不到文件）&lt;/li&gt;
&lt;li&gt;在node上 cd shell &amp;amp;&amp;amp; sh init.sh  。然后在node上执行master输出的join命令即可&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;高可用如下&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>配置docker engine使engine挂掉时容器继续运行</title>
      <link>https://sealyun.com/blog/2014/07/11/keep_containers_alive_deamon_downtme/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/keep_containers_alive_deamon_downtme/</guid>
      <description>&lt;h2 id=&#34;配置docker-engine使engine挂掉时容器继续运行&#34;&gt;配置docker engine使engine挂掉时容器继续运行&lt;/h2&gt;

&lt;p&gt;两种方式：
* 修改/etc/docker/daemon.json 如果不想engine重启，给engine发送SIGHUP信号使engine重新加载配置文件
* 直接加启动参数：&amp;ndash;live-restore,  如用systemd管理修改这个配置文件：/usr/lib/systemd/system/docker.service,
  然后执行systemctl daemon-reload &amp;amp;&amp;amp; service docker restart&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://sealyun.com/changelog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sealyun.com/changelog/</guid>
      <description>离线包Changelog  1.15.3版本
 社区：
 更新golang/x/net依赖项以引入CVE-2019-9512，CVE-2019-9514 修复了使用内联卷源创建的VolumeAttachment API对象的验证。（＃80945，@tedyu） KUBE-插件管理器已更新至v9.0.2固定在党魁选举中的错误（https://github.com/kubernetes/kubernetes/pull/80575）（＃80861，@mborsz） 修复了ListOptions.AllowWatchBookmarks未在kube-apiserver中正确传播的错误。（＃80157，@ wojtek -t） CSI的节点上的传递卷MountOptions到全局挂载（NodeStageVolume）（＃80191，@ davidz627） kubeadm join &amp;ndash;discovery-file使用具有嵌入凭据的发现文件时修复错误（＃80675，@ fabiziopandini） 修正：支持原始块的csi插件不需要附加挂载失败（＃79920，@ cwdsuzhou）  sealyun:
 使用patch的方式更新kubeadm代码 maxage 增加到99年   1.14.5 与1.15.2版本
 社区：
 无重大更新  sealyun:
更新kubelet开机启动依赖, 开机自动启动ipvs，自动拉起其它所有服务：
[root@iZj6cgg9qmj6d5vq9wthk3Z ~]# cat /etc/systemd/system/kubelet.service [Unit] Description=kubelet: The Kubernetes Node Agent Documentation=http://kubernetes.io/docs/ [Service] ExecStart=/usr/bin/kubelet ExecStartPre=/usr/bin/kubelet-pre-start.sh  [root@iZj6cgg9qmj6d5vq9wthk3Z ~]# cat /usr/bin/kubelet-pre-start.sh #!/bin/bash # Open ipvs modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack_ipv4 cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/sysctl.</description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>https://sealyun.com/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sealyun.com/contact/</guid>
      <description>联系我们 微信群：sealnux QQ群：98488045 公众号：sealyun</description>
    </item>
    
    <item>
      <title>kubernetes安装常见问题总结</title>
      <link>https://sealyun.com/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sealyun.com/faq/</guid>
      <description>https://github.com/fanux/fanux.github.io/issues/3
 重启机器kubelet起不来？
 确保selinux swap 已经关闭。 swapoff -a&amp;amp;&amp;amp; setenforce 0&amp;amp;&amp;amp;systemctl start kubelet 执行后会拉起其他服务
永久关闭swap:
1. Identify configured swap devices and files with cat /proc/swaps. 2. Turn off all swap devices and files with swapoff -a. 3. Remove any matching reference found in /etc/fstab  永久关闭selinux:
vim /etc/sysconfig/selinux SELINUX=enforcing 改为 SELINUX=disabled   chrome 浏览器可能访问不了dashboard
 是因为新版chrome安全检测太严格，不认自签证书，要解决可以使用火狐，或者自己买证书给dashboard配置上。 访问不了dashboard先检查pod有没有启动成功kubectl get pod -n kube-system，再在节点上用curl检查，如果能curl到 那就是浏览器的原因了。注意是https
自己创建证书：
1.用openssl创建证书
$ mkdir certs $ cd certs $ openssl genrsa -des3 -passout pass:x -out dashboard.</description>
    </item>
    
  </channel>
</rss>