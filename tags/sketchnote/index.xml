<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sketchnote on SealYun</title>
    <link>https://sealyun.com/tags/sketchnote/</link>
    <description>Recent content in Sketchnote on SealYun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 23 Jun 2019 10:54:24 +0200</lastBuildDate>
    
	<atom:link href="https://sealyun.com/tags/sketchnote/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>macvtap实践教程</title>
      <link>https://sealyun.com/blog/2019/06/23/macvtap/</link>
      <pubDate>Sun, 23 Jun 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/06/23/macvtap/</guid>
      <description>&lt;p&gt;macvtap是虚拟机网络虚拟化常用的一种技术，当然容器也可以用. MACVTAP 的实现基于传统的 MACVLAN. 和 TAP 设备一样，每一个 MACVTAP 设备拥有一个对应的 Linux 字符设备，并拥有和 TAP 设备一样的 IOCTL 接口，因此能直接被 KVM/Qemu使用，方便地完成网络数据交换工作. 引入 MACVTAP 设备的目标是：简化虚拟化环境中的交换网络，代替传统的 Linux TAP 设备加 Bridge 设备组合，同时支持新的虚拟化网络技术，如 802.1 Qbg.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>强隔离容器那些事</title>
      <link>https://sealyun.com/blog/2019/06/22/kubernetes-vm/</link>
      <pubDate>Sat, 22 Jun 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/06/22/kubernetes-vm/</guid>
      <description>&lt;p&gt;探讨可加QQ群：98488045&lt;/p&gt;

&lt;p&gt;强隔离容器的那些事&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么需要强隔离容器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们在生产环境中运行容器已久，第一次对强隔离容器诉求是java类应用引起的，如果不配置jvm参数，java虚拟机会根据系统资源信息进行内存gc线程数等配置，在不给容器配额的情况下问题不大，一旦配额了。。。&lt;/p&gt;

&lt;p&gt;普通的容器在容器中看到的资源还是宿主机的资源，那么假设宿主机128G而你给容器配额2G，此时堆内存按照128G去分，可想而知后果，同理还有gc线程数等&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes Admission Controller原理介绍</title>
      <link>https://sealyun.com/blog/2019/05/23/kube-admin-control/</link>
      <pubDate>Thu, 23 May 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/05/23/kube-admin-control/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Admission Controller介绍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apiserver干的最重要的三个事就是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;认证 : 看是否是合法用户&lt;/li&gt;
&lt;li&gt;授权 : 看用户具备哪些权限&lt;/li&gt;
&lt;li&gt;admission controller : 一个调用链，对请求进行控制或修改，比如是否允许这个请求。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;admission controller非常有用，也是经常会用到的k8s的一个扩展方式，今天在源码级别对其做一下介绍，以及如何自己去开发一个admission controller.&lt;/p&gt;

&lt;p&gt;我们的应用场景是：我们希望把所有需要创建的pod都加上一个注解，因为我们早期是通过podpreset给pod注入lxcfs的配置的，但是用户在写yaml文件时很容易忘记加上，所以需要在apiserver上来个自动处理&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes开发流程</title>
      <link>https://sealyun.com/blog/2019/05/01/dev-k8s-workflow/</link>
      <pubDate>Wed, 01 May 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/05/01/dev-k8s-workflow/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;本文介绍如何对kubernetes进行二次开发，仓库如何管理，git分支如何管理，怎样利用CI去编译与发布以及如何给社区贡献代码等，结合实际例子，望对大家有所帮助。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>最简单的kubernetes HA安装方式-sealos详解</title>
      <link>https://sealyun.com/blog/2019/04/15/sealos2.0/</link>
      <pubDate>Mon, 15 Apr 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/04/15/sealos2.0/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;本文教你如何用一条命令构建k8s高可用集群且不依赖haproxy和keepalived，也无需ansible。通过内核ipvs对apiserver进行负载均衡，并且带apiserver健康检测。&lt;/p&gt;

&lt;h1 id=&#34;快速入门&#34;&gt;快速入门&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fanux/sealos&#34;&gt;sealos项目地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;准备条件&#34;&gt;准备条件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;装好docker并启动docker&lt;/li&gt;
&lt;li&gt;把&lt;a href=&#34;http://store.lameleg.com&#34;&gt;离线安装包&lt;/a&gt; 下载好拷贝到所有节点的/root目录下, 不需要解压，如果有文件服务器更好，sealos支持从一个服务器上wget到所有节点上&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>k8s高可用一个kubeadm搞定,无依赖keepalived haproxy ansible</title>
      <link>https://sealyun.com/blog/2019/04/01/super-kubeadm/</link>
      <pubDate>Mon, 01 Apr 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/04/01/super-kubeadm/</guid>
      <description>&lt;p&gt;探讨可加QQ群：98488045&lt;/p&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;地址&lt;a href=&#34;https://github.com/fanux/sealos&#34;&gt;sealos&lt;/a&gt;, 让kubernetes高可用不再需要keepalived haproxy和ansible,&lt;/p&gt;

&lt;p&gt;sealyun定制超级版kubeadm通过ipvs代理多个master，优雅解决k8s高可用问题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>tektoncd pipeline教程 - kubernetes原生pipeline</title>
      <link>https://sealyun.com/blog/2019/03/27/tektoncd-pipeline/</link>
      <pubDate>Wed, 27 Mar 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/03/27/tektoncd-pipeline/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概览&#34;&gt;概览&lt;/h1&gt;

&lt;p&gt;Tekton Pipeline,是一个k8s native的pipeline, 任务跑在pod中，通过自定义CRD去管理任务与工作流等等，我看完tekton之后感觉是功能很强大，但是有点过度设计了，没有drone的简约大方灵活之感&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于overlay2存储驱动的磁盘配额问题</title>
      <link>https://sealyun.com/blog/2019/03/23/docker-oerlay2/</link>
      <pubDate>Sat, 23 Mar 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/03/23/docker-oerlay2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;这篇短文向大家介绍一下正确使用存储驱动的姿势，非常有用。&lt;/p&gt;

&lt;h2 id=&#34;为啥要用overlay2&#34;&gt;为啥要用overlay2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;docker centos（内核3.10）上默认存储驱动是devicemapper 的loop-lvm模式，这种模式是用文件模拟块设备，不推荐生产使用&lt;/li&gt;
&lt;li&gt;direct lvm又不是一个开箱即用的模式，懒得配置&lt;/li&gt;
&lt;li&gt;最关键的是 docker in docker的情况下 device mapper是行不通的，典型的场景就是用drone时，构建docker镜像就不能正常工作&lt;/li&gt;
&lt;li&gt;overlay存储驱动层数过多时会导致文件链接数过多可能会耗尽inode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以当前overlay2是个比较好的选择&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>containerd与kubernetes集成</title>
      <link>https://sealyun.com/blog/2019/03/11/containerd/</link>
      <pubDate>Mon, 11 Mar 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/03/11/containerd/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;概念介绍&#34;&gt;概念介绍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;cri (Container runtime interface)

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cri&lt;/code&gt; is a &lt;a href=&#34;https://containerd.io/&#34;&gt;containerd&lt;/a&gt; plugin implementation of Kubernetes &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/apis/cri/runtime/v1alpha2/api.proto&#34;&gt;container runtime interface (CRI)&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;cri是 kubernetes的容器运行时接口的容器插件实现。&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://sealyun.com/cri.jpg&#34; alt=&#34;CRI&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;containerd

&lt;ul&gt;
&lt;li&gt;containerd is an industry-standard container runtime with an emphasis on simplicity, robustness and portability.&lt;/li&gt;
&lt;li&gt;containerd完全支持运行容器的的CRI运行时规范。&lt;/li&gt;
&lt;li&gt;cri在containerd1.1以上的版本的原生插件。它内置于containerd并默认启用。&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://sealyun.com/containerd.png&#34; alt=&#34;containerd&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>kubernetes 用户token教程</title>
      <link>https://sealyun.com/blog/2019/02/20/user-token/</link>
      <pubDate>Wed, 20 Feb 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/02/20/user-token/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;kubernetes server account的token很容易获取，但是User的token非常麻烦，本文给出一个极简的User token生成方式，让用户可以一个http请求就能获取到。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>属于极客的k8s管理工具fist, 强大的webterminal</title>
      <link>https://sealyun.com/blog/2019/02/05/fist-terminal/</link>
      <pubDate>Tue, 05 Feb 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/02/05/fist-terminal/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fanux/fist&#34;&gt;fist&lt;/a&gt;是sealyun开发的精致的k8s管理工具，所有功能切入要害，而不追求多与重，接下来的介绍我相信有节操的k8s管理员一定会喜欢它。&lt;/p&gt;

&lt;h1 id=&#34;terminal功能安装&#34;&gt;terminal功能安装&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fanux/fist/blob/master/terminal/README.md&#34;&gt;安装地址&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;集成kubectl&#34;&gt;集成kubectl&lt;/h1&gt;

&lt;p&gt;terminal中可直接使用kubectl，用户就不需要登录到机器上或者自己装kubectl远程访问集群，当然这是基本功能&lt;/p&gt;

&lt;h1 id=&#34;自动渲染kubeconfig文件&#34;&gt;自动渲染kubeconfig文件&lt;/h1&gt;

&lt;p&gt;会根据传入的token去创建.kube/config 文件，如何给用户创建token &lt;a href=&#34;https://github.com/fanux/fist#auth&#34;&gt;看这里&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>rook使用教程，快速编排ceph</title>
      <link>https://sealyun.com/blog/2019/01/23/rook/</link>
      <pubDate>Wed, 23 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/23/rook/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文中需要用的yaml文件和Dockerfile等都放到这个&lt;a href=&#34;https://github.com/sealyun/rook&#34;&gt;仓库&lt;/a&gt;
包含：rook operator ceph cluster storage class配置，mysql wordpress事例，性能测试fio Dockerfile与yaml等&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>基于Envoy的Ingress controller使用介绍</title>
      <link>https://sealyun.com/blog/2019/01/23/envoy-ingress/</link>
      <pubDate>Wed, 23 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/23/envoy-ingress/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;ingress controller有很多，这里介绍其中一个&lt;a href=&#34;https://github.com/heptio/contour&#34;&gt;contour&lt;/a&gt;, 我没有使用ingress controller的原因是&lt;/p&gt;

&lt;p&gt;首先contour的实现是envoy, 其动态配置能力强于nginx，其次可以非常方便的对接监控系统，也是istio的核心组件。 本文其实还是以ingress的用法
为主, 因为不管是什么实现都兼容ingress的配置标准&lt;/p&gt;

&lt;p&gt;还有就是contour是唯一实现了自定义IngressRoute CRD来实现更复杂的路由功能，websocket支持，健康检测，prefix rewite支持,还有TCP代理&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>是时候表现一下我的vim了</title>
      <link>https://sealyun.com/blog/2019/01/23/vim/</link>
      <pubDate>Wed, 23 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/23/vim/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;
探讨可加QQ群：98488045&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;使用vim作golang开发&#34;&gt;使用vim作golang开发&lt;/h1&gt;

&lt;p&gt;分享一些我使用的vim插件，以及制作过程，最终的功能有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;golang开发，补全，跳转，文件列表，函数列表等&lt;/li&gt;
&lt;li&gt;kubernetes插件，方便写yaml文件&lt;/li&gt;
&lt;li&gt;好看的颜色主题&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>keepalived in docker</title>
      <link>https://sealyun.com/blog/2019/01/10/keepalived/</link>
      <pubDate>Thu, 10 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/10/keepalived/</guid>
      <description>&lt;h1 id=&#34;kubernetes集群三步安装-https-sealyun-com-pro-products&#34;&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;目前keepalived作为kubernetes集群高可用的重要组件，保障虚拟ip可以在多个主机间漂移，&lt;a href=&#34;https://github.com/fanux/sealos&#34;&gt;sealos&lt;/a&gt; 也是使用了，只是在方案上与传统的方式有很大区别&lt;/p&gt;

&lt;p&gt;首先把keepalived放到容器里了，版本也用了比较新的2.x.x以上&lt;/p&gt;

&lt;p&gt;然后使用kubernetes static pod去管理keepalived服务&lt;/p&gt;

&lt;h1 id=&#34;keepalived放到容器里的好处&#34;&gt;keepalived放到容器里的好处&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;安装成功率更高，更跨平台, 传统方式如用yum安装或者其它，如果采用那些办法在别的一些发型版系统上sealos就不可用。其次，很多系统的源不一样导致版本不一致造成问题，如果通过源码编译可能一些系统库版本直接导致编译不通过，所以为了提高高可用的安装成功率，放容器里是最好的方式&lt;/li&gt;
&lt;li&gt;无需额外对keepalived增加监控, 因为是pod，而sealos又已经集成了prometheus，所以不需要再额外添加监控信息&lt;/li&gt;
&lt;li&gt;统一管理, keepalived异常退出什么的kubelet也会将其拉起，与其它的kubernetes组件就有了一个统一的方式管理&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>关于sealyun营销系统</title>
      <link>https://sealyun.com/blog/2019/01/06/referrer/</link>
      <pubDate>Sun, 06 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/06/referrer/</guid>
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;任何用户都可以通过sealyun赚钱，很方便的获取到一个分享链接，如果别的用户是通过你的分享链接购买商品的那么您将获得一笔不错的提成，目前是交易金额的60%，&lt;/p&gt;

&lt;p&gt;也就是如商品50元，别的用户通过您的链接购买成功，您可获得30元，平台获得20元&lt;/p&gt;

&lt;h1 id=&#34;操作步骤&#34;&gt;操作步骤&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;获取营销链接 &lt;a href=&#34;http://store.lameleg.com/&#34;&gt;网站地址http://store.lameleg.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>使用prometheus operator监控envoy</title>
      <link>https://sealyun.com/blog/2019/01/01/prometheus-operator-envoy/</link>
      <pubDate>Tue, 01 Jan 2019 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2019/01/01/prometheus-operator-envoy/</guid>
      <description>&lt;h1 id=&#34;kubernetes集群三步安装-https-sealyun-com-pro-products&#34;&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;prometheus operator应当是使用监控系统的最佳实践了，首先它一键构建整个监控系统，通过一些无侵入的手段去配置如监控数据源等
故障自动恢复，高可用的告警等。。&lt;/p&gt;

&lt;p&gt;不过对于新手使用上还是有一丢丢小门槛，本文就结合如何给envoy做监控这个例子来分享使用prometheus operator的正确姿势&lt;/p&gt;

&lt;p&gt;至于如何写告警规则，如何配置prometheus查询语句不是本文探讨的重点，会在后续文章中给大家分享，本文着重探讨如何使用prometheus operator&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kube-scheduler定制，支持深度学习批处理任务调度</title>
      <link>https://sealyun.com/blog/2018/12/25/kube-batch/</link>
      <pubDate>Tue, 25 Dec 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/12/25/kube-batch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;什么是批处理任务&#34;&gt;什么是批处理任务&lt;/h1&gt;

&lt;p&gt;深度学习中经常会出现多机多卡的任务，也就是同事会起多个pod，但是这多个pod属于同一个任务。&lt;/p&gt;

&lt;p&gt;这样就会有一个问题&lt;/p&gt;

&lt;p&gt;一个任务要起100个pod，每个pod需要一张卡，总共需要100张GPU卡，而集群中只有99张空闲的GPU卡，这样默认的k8s调度器会如何处理？&lt;/p&gt;

&lt;p&gt;因为默认调度器是一个一个pod调度的，只会检查单个pod资源够不够，这样前99个都能成功，最后一个pod调度失败。&lt;/p&gt;

&lt;p&gt;这样非常有可能造成&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;任务跑不了&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;前99个占着GPU不释放，新的任务无法调度&lt;/li&gt;
&lt;li&gt;严重时整个集群死锁，都“占着茅坑不拉屎”&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>sealyun kubernetes离线包文档</title>
      <link>https://sealyun.com/blog/2018/12/11/docs/</link>
      <pubDate>Tue, 11 Dec 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/12/11/docs/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://store.lameleg.com/&#34;&gt;kubernetes安装包store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://store.lameleg.com/&#34;&gt;官方销售市场&lt;/a&gt;：&lt;a href=&#34;http://store.lameleg.com/&#34;&gt;http://store.lameleg.com/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;阿里云市场购买下载地址列表&lt;/a&gt;：&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;https://sealyun.com/pro/products/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;商品介绍&#34;&gt;商品介绍&lt;/h1&gt;

&lt;p&gt;安装包通过kubeadm安装kubernetes集群,包含：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;核心基础组件 etcd apisver kubelet kube-proxy scheduler manager&lt;/li&gt;
&lt;li&gt;addon组件    dashboard calico promethus grafana alertmanager node-exporter coreDNS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启用IPVS&lt;/p&gt;

&lt;p&gt;可以内网环境进行安装，但是不包含docker&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubeadm杂谈</title>
      <link>https://sealyun.com/blog/2018/12/04/kubeadm/</link>
      <pubDate>Tue, 04 Dec 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/12/04/kubeadm/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;kubeadm-1-13版本&#34;&gt;kubeadm 1.13版本&lt;/h1&gt;

&lt;p&gt;此版本更新了不少东西，以前老的配置不再适用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;W1205 19:10:23.541054   58540 strict.go:54] error unmarshaling configuration schema.GroupVersionKind{Group:&amp;quot;kubeadm.k8s.io&amp;quot;, Version:&amp;quot;v1beta1&amp;quot;, Kind:&amp;quot;InitConfiguration&amp;quot;}: error unmarshaling JSON: while decoding JSON: json: unknown field

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>修改kubeadm证书过期时间</title>
      <link>https://sealyun.com/blog/2018/11/07/kubeadm-dev/</link>
      <pubDate>Wed, 07 Nov 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/11/07/kubeadm-dev/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;修改kubeadm证书过期时间&#34;&gt;修改kubeadm证书过期时间&lt;/h1&gt;

&lt;p&gt;本文通过修改kubeadm源码让kubeadm默认的一年证书过期时间修改为99年&lt;/p&gt;

&lt;p&gt;我已经编译好了一个放在了&lt;a href=&#34;https://github.com/fanux/sealos/releases/tag/kubeadm1.12.2&#34;&gt;github&lt;/a&gt;上，有需要的可以直接下&lt;/p&gt;

&lt;p&gt;使用方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@dev-86-202 ~]# chmod +x kubeadm &amp;amp;&amp;amp; cp kubeadm /usr/bin
[root@dev-86-202 ~]# rm /etc/kubernetes/pki/ -rf
[root@dev-86-202 ~]# kubeadm alpha phase certs all --config  kube/conf/kubeadm.yaml
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>kubernetes源码分析之kube-scheduler - 从代码看原理</title>
      <link>https://sealyun.com/blog/2018/11/06/kube-scheduler-source-code/</link>
      <pubDate>Tue, 06 Nov 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/11/06/kube-scheduler-source-code/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;kube-scheduler源码分析&#34;&gt;kube-scheduler源码分析&lt;/h1&gt;

&lt;h2 id=&#34;关于源码编译&#34;&gt;关于源码编译&lt;/h2&gt;

&lt;p&gt;我嫌弃官方提供的编译脚本太麻烦，所以用了更简单粗暴的方式编译k8s代码，当然官方脚本在编译所有项目或者夸平台编译以及realse时还是挺有用的。&lt;/p&gt;

&lt;p&gt;在容器中编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -v /work/src/k8s.io/kubernetes:/go/src/k8s.io/kubernetes golang:1.11.2 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在容器中可以保证环境干净&lt;/p&gt;

&lt;p&gt;进入bash后直接进入kube-scheduler的主目录编译即可&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>构建生产环境可用的高可用kubernetes集群</title>
      <link>https://sealyun.com/blog/2018/10/24/sealos/</link>
      <pubDate>Wed, 24 Oct 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/10/24/sealos/</guid>
      <description>&lt;h1 id=&#34;kubernetes集群三步安装-https-sealyun-com-pro-products&#34;&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;k8s-1-14以上版本请直接参考-sealos-readme-https-github-com-fanux-sealos&#34;&gt;k8s 1.14以上版本请直接参考&lt;a href=&#34;https://github.com/fanux/sealos&#34;&gt;sealos readme&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;sealos是一个轻量级kubernetes HA安装项目，重点关注功能的收敛而非庞大复杂厚重，旨在容易定制。除kubelet意外其它任何组件均在容器中运行
这样做的好处有几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保证一致性，这样避免掉很多因宿主环境问题导致的安装失败，如keepalived版本问题，系统库问题等等&lt;/li&gt;
&lt;li&gt;统一管理统一监控，这样我们就不需要为如keepalived etcd haproxy单独配置进程级别的监控，仅要监控pod即可，kubelet也会对这些容器做比较好的管理，如自动拉起等&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>基于drone构建CI/CD系统,对接k8s</title>
      <link>https://sealyun.com/blog/2018/10/10/ci-cd/</link>
      <pubDate>Wed, 10 Oct 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/10/10/ci-cd/</guid>
      <description>&lt;h1 id=&#34;kubernetes集群三步安装-https-sealyun-com-pro-products&#34;&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;ci-概述&#34;&gt;CI 概述&lt;/h1&gt;

&lt;h3 id=&#34;用一个可描述的配置定义整个工作流&#34;&gt;用一个可描述的配置定义整个工作流&lt;/h3&gt;

&lt;p&gt;程序员是很懒的动物，所以想各种办法解决重复劳动的问题，如果你的工作流中还在重复一些事，那么可能就得想想如何优化了&lt;/p&gt;

&lt;p&gt;持续集成就是可以帮助我们解决重复的代码构建，自动化测试，发布等重复劳动，通过简单一个提交代码的动作，解决接下来要做的很多事。&lt;/p&gt;

&lt;p&gt;容器技术使这一切变得更完美。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>etcd管理指南</title>
      <link>https://sealyun.com/blog/2018/08/12/etcd-manage/</link>
      <pubDate>Sun, 12 Aug 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/08/12/etcd-manage/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;广告 | &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;kubernetes各版本离线安装包&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;etcd-证书配置&#34;&gt;etcd 证书配置&lt;/h1&gt;

&lt;p&gt;生产环境中给etcd配置证书相当重要，如果没有证书，那么k8s集群很容易被黑客利用而去挖矿什么的。做法非常简单，比如你下了一个不安全的镜像，通过程序扫描到etcd的ip和端口，那么黑客就可以绕开apiserver的认证直接写数据，写一些deployment pod等等，apiserver就会读到这些，从而去部署黑客的程序。 我们就有一个集群这样被利用去挖矿了,安全无小事，如果黑客恶意攻击也可轻松删除你的所有数据，所以证书与定期备份都很重要,即便有多个etcd节点，本文深入探讨etcd管理的重要的几个东西。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes dashboard监控数据无法正常显示</title>
      <link>https://sealyun.com/blog/2018/08/10/heapster-error/</link>
      <pubDate>Fri, 10 Aug 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/08/10/heapster-error/</guid>
      <description>&lt;h1 id=&#34;kubernetes集群三步安装-https-sealyun-com-pro-products&#34;&gt;&lt;a href=&#34;https://sealyun.com/pro/products/&#34;&gt;kubernetes集群三步安装&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;kubernetes1-12-0版本dashboard使用heapster无法正常显示监控数据&#34;&gt;kubernetes1.12.0版本dashboard使用heapster无法正常显示监控数据&lt;/h1&gt;

&lt;p&gt;查看heapster日志：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E0228 20:01:05.019281       1 manager.go:101] Error in scraping containers from kubelet:30.0.1.4:10255: failed to get all container stats from Kubelet URL &amp;quot;http://30.0.1.4:10255/stats/container/&amp;quot;: Post http://30.0.1.4:10255/stats/container/: dial tcp 30.0.1.4:10255: getsockopt: connection refused
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>istio安装使用教程</title>
      <link>https://sealyun.com/blog/2018/07/30/istio-quickstart/</link>
      <pubDate>Mon, 30 Jul 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/07/30/istio-quickstart/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;广告 | &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;kubernetes各版本离线安装包&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;祝贺istio1.0发布, 在此献上教程一份&lt;/p&gt;

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;安装k8s &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;强势插播广告&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;三步安装，不多说&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;安装helm, 推荐生产环境用helm安装，可以调参&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>kubernetes开发指南</title>
      <link>https://sealyun.com/blog/2018/06/21/kube-dev/</link>
      <pubDate>Thu, 21 Jun 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/06/21/kube-dev/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;广告 | &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;kubernetes离线安装包，仅需三步&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;官方例子&#34;&gt;官方例子&lt;/h2&gt;

&lt;p&gt;大部分使用方式调用clientgo即可，我增加一些clientgo事例里没有的一些技巧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/client-go/tree/master/examples&#34;&gt;clientgo 事例地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;初始化客户端&#34;&gt;初始化客户端&lt;/h2&gt;

&lt;p&gt;这里给了两种初始化kubernetes客户端的方式，一种根据kubeconfig文件的路径，官方有，比较简单&lt;/p&gt;

&lt;p&gt;另一种就是根据kubeconfig内容的字符串去初始化一个客户端，这种方式应用场景是比如我们把很多的kubeconfig文件存在了数据库中（多租户时）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kube-proxy源码解析</title>
      <link>https://sealyun.com/blog/2018/06/20/kube-proxy-src/</link>
      <pubDate>Wed, 20 Jun 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/06/20/kube-proxy-src/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;广告 | &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;kubernetes离线安装包，仅需三步&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;kube-proxy源码解析&#34;&gt;kube-proxy源码解析&lt;/h1&gt;

&lt;p&gt;ipvs相对于iptables模式具备较高的性能与稳定性, 本文讲以此模式的源码解析为主，如果想去了解iptables模式的原理，可以去参考其实现，架构上无差别。&lt;/p&gt;

&lt;p&gt;kube-proxy主要功能是监听service和endpoint的事件，然后下放代理策略到机器上。 底层调用&lt;a href=&#34;https://github.com/docker/libnetwork&#34;&gt;docker/libnetwork&lt;/a&gt;, 而libnetwork最终调用了&lt;a href=&#34;https://github.com/vishvananda/netlink&#34;&gt;netlink&lt;/a&gt; 与netns来实现ipvs的创建等动作&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes启用ipvs</title>
      <link>https://sealyun.com/blog/2018/05/29/k8s-ipvs/</link>
      <pubDate>Tue, 29 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/05/29/k8s-ipvs/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;广告 | &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;kubernetes各版本离线安装包&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-11-1版本已经修复此bug-如在centos下使用ipvs模式建议升级到-v1-11-1-包地址-http-sealyun-com-pro-products&#34;&gt;1.11.1版本已经修复此bug，如在centos下使用ipvs模式建议升级到&lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;v1.11.1,包地址&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;1-11-0版本ipset-bug说明&#34;&gt;1.11.0版本ipset bug说明&lt;/h1&gt;

&lt;p&gt;1.11.0版本centos下使用ipvs模式会出问题 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/65461&#34;&gt;65461&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Jun 25 20:50:00 VM_3_4_centos kube-proxy[3828]: E0625 20:50:00.312569    3828 ipset.go:156] Failed to make sure ip set: &amp;amp;{{KUBE-LOOP-BACK hash:ip,port,ip inet 1024 65536 0-65535 Kubernetes endpoints dst ip:port, source ip for solving hairpin purpose} map[] 0xc42073e1d0} exist, error: error creating ipset KUBE-LOOP-BACK, error: exit status 2
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>kubeadm源码分析</title>
      <link>https://sealyun.com/blog/2018/05/11/kubeadm-source/</link>
      <pubDate>Fri, 11 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/05/11/kubeadm-source/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;k8s离线安装包&lt;/a&gt; 三步安装，简单到难以置信&lt;/p&gt;

&lt;h1 id=&#34;kubeadm源码分析&#34;&gt;kubeadm源码分析&lt;/h1&gt;

&lt;p&gt;说句实在话，kubeadm的代码写的真心一般，质量不是很高。&lt;/p&gt;

&lt;p&gt;几个关键点来先说一下kubeadm干的几个核心的事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kubeadm 生成证书在/etc/kubernetes/pki目录下&lt;/li&gt;
&lt;li&gt;kubeadm 生成static pod yaml配置，全部在/etc/kubernetes/manifasts下&lt;/li&gt;
&lt;li&gt;kubeadm 生成kubelet配置，kubectl配置等 在/etc/kubernetes下&lt;/li&gt;
&lt;li&gt;kubeadm 通过client go去启动dns&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>kubernetes RBAC实战</title>
      <link>https://sealyun.com/blog/2018/05/11/k8s-rbac/</link>
      <pubDate>Fri, 11 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/05/11/k8s-rbac/</guid>
      <description>&lt;h2 id=&#34;kubernetes-rbac实战&#34;&gt;kubernetes RBAC实战&lt;/h2&gt;

&lt;h2 id=&#34;环境准备&#34;&gt;环境准备&lt;/h2&gt;

&lt;p&gt;先用kubeadm安装好kubernetes集群，&lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;包地址在此&lt;/a&gt; 好用又方便，服务周到，童叟无欺&lt;/p&gt;

&lt;p&gt;本文目的，让名为devuser的用户只能有权限访问特定namespace下的pod&lt;/p&gt;

&lt;h2 id=&#34;命令行kubectl访问&#34;&gt;命令行kubectl访问&lt;/h2&gt;

&lt;h3 id=&#34;安装cfssl&#34;&gt;安装cfssl&lt;/h3&gt;

&lt;p&gt;此工具生成证书非常方便, pem证书与crt证书,编码一致可直接使用&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes对接第三方认证</title>
      <link>https://sealyun.com/blog/2018/05/11/k8s-authenticating/</link>
      <pubDate>Fri, 11 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/05/11/k8s-authenticating/</guid>
      <description>&lt;h1 id=&#34;kubernetes对接第三方认证&#34;&gt;kubernetes对接第三方认证&lt;/h1&gt;

&lt;p&gt;广告： &lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;安装包地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;本文介绍如何使用github账户去关联自己kubernetes账户。达到如下效果：
1. 使用github用户email作为kubernetes用户，如fhtjob@hotmail.com
2. 创建对应的clusterrole绑定给fhtjob@hotmail.com这个用户
3. 给fhtjob@hotmail这个用户创建一个kubeconfig文件，让改用户可以使用kubectl命令操作集群，且只有部分权限&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes高可用相关配置</title>
      <link>https://sealyun.com/blog/2018/05/11/k8s-ha-conf/</link>
      <pubDate>Fri, 11 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/05/11/k8s-ha-conf/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/setup/independent/high-availability/&#34;&gt;kubeadm HA教程&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;机器&#34;&gt;机器&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10.100.81.11&lt;/td&gt;
&lt;td&gt;master、etcd&lt;/td&gt;
&lt;td&gt;主节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.12&lt;/td&gt;
&lt;td&gt;master、etcd、keepalived、haproxy&lt;/td&gt;
&lt;td&gt;主节点，同时部署keepalived、haproxy，保证master高可用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.13&lt;/td&gt;
&lt;td&gt;master、etcd、keepalived、haproxy&lt;/td&gt;
&lt;td&gt;主节点，同时部署keepalived、haproxy，保证master高可用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.14&lt;/td&gt;
&lt;td&gt;node、etcd&lt;/td&gt;
&lt;td&gt;非业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.15&lt;/td&gt;
&lt;td&gt;node、etcd&lt;/td&gt;
&lt;td&gt;非业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.16&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.17&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.18&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.19&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.20&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.21&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.22&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.23&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.24&lt;/td&gt;
&lt;td&gt;node、harbor&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10.100.81.25&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;业务节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;组件版本&#34;&gt;组件版本&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>k8s离线包解析</title>
      <link>https://sealyun.com/blog/2018/04/24/sealyun-k8s-offline/</link>
      <pubDate>Tue, 24 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2018/04/24/sealyun-k8s-offline/</guid>
      <description>&lt;h1 id=&#34;k8s离线包解析&#34;&gt;k8s离线包解析&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://sealyun.com/pro/products/&#34;&gt;产品地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;鸣谢&#34;&gt;鸣谢&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;大家好，首先感谢大家对我们产品的支持，特别是一些老客户的持续支持，让我可以有动力把这个事情持续进行下去。&lt;/li&gt;
&lt;li&gt;感谢大家对付费产品的认可，尊重付费&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;产品介绍&#34;&gt;产品介绍&lt;/h2&gt;

&lt;p&gt;我们专注于k8s离线包的制作，优化细节，让大家可以很方便快速的安装k8s集群。
下面详细介绍安装包的原理以及如何去制作一个这样的包，大家参考我的方法也可以制作自己想要的版本然后用于自己的离线环境&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker架构分析</title>
      <link>https://sealyun.com/blog/2017/07/11/docker-architech/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/docker-architech/</guid>
      <description>&lt;h2 id=&#34;docker架构分析&#34;&gt;Docker架构分析&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[root@docker-build-86-050 ~]# ls /usr/bin |grep docker
docker
docker-compose
docker-containerd
docker-containerd-ctr
docker-containerd-shim
dockerd
docker-proxy
docker-runc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家一定很困惑 dockerd, containerd, ctr,shim, runc,等这几个进程的关系到底是啥&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>calico 网络原理</title>
      <link>https://sealyun.com/blog/2017/07/11/calico/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/calico/</guid>
      <description>&lt;h1 id=&#34;calico-网络原理&#34;&gt;calico 网络原理&lt;/h1&gt;

&lt;h3 id=&#34;node节点-装网络之前路由&#34;&gt;node节点 装网络之前路由&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[root@iZj6c3cqwumhn5jov661z7Z ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.31.255.253  0.0.0.0         UG    0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
172.31.240.0    0.0.0.0         255.255.240.0   U     0      0        0 eth0
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>calico架构</title>
      <link>https://sealyun.com/blog/2017/07/11/calico-architecture/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/calico-architecture/</guid>
      <description>&lt;h2 id=&#34;安装常见问题&#34;&gt;安装常见问题&lt;/h2&gt;

&lt;p&gt;calico无法启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Readiness probe failed: calico/node is not ready: felix is not ready: Get http://localhost:9099/readiness: dial tcp [::1]:9099: connect: connection refused 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很可能是网卡发现有问题，calico虚拟化时没找对网卡，calico会经常找docker0网桥，导致clusterIP不通从而calico node连不上etcd&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>calico网络策略</title>
      <link>https://sealyun.com/blog/2017/07/11/calico-network-policy/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/calico-network-policy/</guid>
      <description>&lt;h2 id=&#34;calico网络策略&#34;&gt;calico网络策略&lt;/h2&gt;

&lt;p&gt;使用kubernetes NetworkPolicy让用户定义pod之间的访问策略，精细的控制哪些pod之间有相互访问的权利，如此网络更安全.&lt;/p&gt;

&lt;h2 id=&#34;教程流程&#34;&gt;教程流程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;创建nginx service&lt;/li&gt;
&lt;li&gt;禁止所有入口流量&lt;/li&gt;
&lt;li&gt;允许向内访问nginx&lt;/li&gt;
&lt;li&gt;禁止所有出口流程&lt;/li&gt;
&lt;li&gt;允许出口流量访问kube-dns&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>kubernetes安装</title>
      <link>https://sealyun.com/blog/2017/07/11/install-k8s/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/install-k8s/</guid>
      <description>&lt;p&gt;alico node &amp;lsquo;iZ2ze3nu0s9j3v57be4xuuZ&amp;rsquo; is already using the IPv4 address 192.168.152.65&lt;/p&gt;

&lt;h3 id=&#34;基础环境&#34;&gt;基础环境&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;关闭防火墙 selinux&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$ systemctl stop firewalld &amp;amp;&amp;amp; systemctl disable firewalld
$ setenforce 0
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;打开forward
sysctl -w net.ipv4.ip_forward=1&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>使用kubeadm安装安全高可用kubernetes集群</title>
      <link>https://sealyun.com/blog/2017/07/11/install-k8s-cluster/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/install-k8s-cluster/</guid>
      <description>&lt;h1 id=&#34;使用kubeadm安装安全高可用kubernetes集群&#34;&gt;使用kubeadm安装安全高可用kubernetes集群&lt;/h1&gt;

&lt;h2 id=&#34;系统架构图&#34;&gt;系统架构图&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;          kubectl dashboard
                 |
                 V 
     +------------------------+ join
     | LB  10.1.245.94        | &amp;lt;--- Nodes
     +------------------------+
     |                                                   
     |--master1 manager1 schedule1   10.1.245.93                                                
     |--master2 manager2 schedule2   10.1.245.95    =============&amp;gt;  etcd cluster  http://10.1.245.93:2379,http://10.1.245.94:2379,http://10.1.245.95:2379
     |--master3 manager3 schedule3   10.1.245.94                                              
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>容器信号使用</title>
      <link>https://sealyun.com/blog/2017/07/11/container-stop-timeout/</link>
      <pubDate>Tue, 11 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2017/07/11/container-stop-timeout/</guid>
      <description>&lt;h2 id=&#34;容器信号使用&#34;&gt;容器信号使用&lt;/h2&gt;

&lt;p&gt;我们跑在容器中的程序通常想在容器退出之前做一些清理操作，比较常用的方式是监听一个信号，延迟关闭容器。&lt;/p&gt;

&lt;p&gt;docker提供了这样的功能：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;╰─➤  docker stop --help

Usage:  docker stop [OPTIONS] CONTAINER [CONTAINER...]

Stop one or more running containers

Options:
      --help       Print usage
  -t, --time int   Seconds to wait for stop before killing it (default 10)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>docker开发流程</title>
      <link>https://sealyun.com/blog/2016/07/11/docker-dev/</link>
      <pubDate>Mon, 11 Jul 2016 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2016/07/11/docker-dev/</guid>
      <description>&lt;h2 id=&#34;docker开发流程&#34;&gt;docker开发流程&lt;/h2&gt;

&lt;p&gt;注意容器构建时的信息：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ovs对接容器网络</title>
      <link>https://sealyun.com/blog/2016/07/11/docker-ovs/</link>
      <pubDate>Mon, 11 Jul 2016 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2016/07/11/docker-ovs/</guid>
      <description>&lt;h1 id=&#34;初始化环境&#34;&gt;初始化环境&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;升级内核：
      rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
      rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm
      yum --enablerepo=elrepo-kernel install  kernel-ml-devel kernel-ml
      awk -F\&#39; &#39;$1==&amp;quot;menuentry &amp;quot; {print $2}&#39; /etc/grub2.cfg
      grub2-set-default 0
      reboot
      uname -a

安装docker:
     yum install -y yum-utils
     yum-config-manager     --add-repo     https://download.docker.com/linux/centos/docker-ce.repo
     yum-config-manager --disable docker-ce-edge
     yum makecache fast
     yum install docker-ce
     service docker start


安装open vswitch:
     yum -y install wget openssl-devel gcc make python-devel openssl-devel kernel-devel graphviz kernel-debug-devel autoconf automake rpm-build redhat-rpm-config libtool python-twisted-core python-zope-interface PyQt4 desktop-file-utils libcap-ng-devel groff checkpolicy selinux-policy-devel
     adduser ovs
     su - ovs
     yum localinstall /home/ovs/rpmbuild/RPMS/x86_64/openvswitch-2.5.0-1.el7.centos.x86_64.rpm -y
     systemctl start openvswitch.service
     systemctl is-active openvswitch
     ovs-vsctl -V
     systemctl enable openvswitch

安装pipework:
     yum install git
     git clone https://github.com/jpetazzo/pipework
     cp pipework/pipework /bin
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>容器网络概述</title>
      <link>https://sealyun.com/blog/2016/07/11/docker-network/</link>
      <pubDate>Mon, 11 Jul 2016 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2016/07/11/docker-network/</guid>
      <description>&lt;h2 id=&#34;网络概述&#34;&gt;网络概述&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;端口映射：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -p 8080:80 nginx:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有这个-p，会发现启动了nginx但是无法通过宿主机访问到web服务，而使用了-p参数后就可以通过访问主机的8080断开去访问nginx了。
端口映射的原理是作了net转发&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;共享主机网络:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --net=host nginx:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种容器没有自己的网络，完全共享主机的网络，所以可以通过主机ip直接访问容器服务。 坏处是容器与其它容器端口冲突&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>iptables教程</title>
      <link>https://sealyun.com/blog/2016/05/11/iptables/</link>
      <pubDate>Wed, 11 May 2016 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2016/05/11/iptables/</guid>
      <description>&lt;h1 id=&#34;iptables教程&#34;&gt;iptables教程&lt;/h1&gt;

&lt;h2 id=&#34;内核空间中的五个包处理位置-和五个函数钩子-规则链&#34;&gt;内核空间中的五个包处理位置，和五个函数钩子（规则链）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PREROUTING 数据包刚进入网络层 , 路由之前&lt;/li&gt;
&lt;li&gt;INPUT 路由判断，流入用户空间&lt;/li&gt;
&lt;li&gt;OUTPUT 用户空间发出，后接路由判断出口的网络接口&lt;/li&gt;
&lt;li&gt;FORWARD 路由判断不进入用户空间，只进行转发&lt;/li&gt;
&lt;li&gt;POSTROUTING 数据包通过网络接口出去&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>golang基于protobuf的rpc使用</title>
      <link>https://sealyun.com/blog/2015/07/11/rpc-protobuf/</link>
      <pubDate>Sat, 11 Jul 2015 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2015/07/11/rpc-protobuf/</guid>
      <description>&lt;h2 id=&#34;golang基于protobuf的rpc使用&#34;&gt;golang基于protobuf的rpc使用&lt;/h2&gt;

&lt;p&gt;基本安装什么的在此不再赘述，不知道的看&lt;a href=&#34;http://www.grpc.io/docs/quickstart/go.html&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;proto文件&#34;&gt;proto文件&lt;/h3&gt;

&lt;p&gt;cat helloworld.proto&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>dns之锅TODO</title>
      <link>https://sealyun.com/blog/2014/07/11/kubernetes-dns/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/kubernetes-dns/</guid>
      <description>&lt;h2 id=&#34;dns之锅&#34;&gt;dns之锅&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;kubectl run --namespace=kube-system access -it --image busybox -- /bin/sh
[root@fortest1513671663-master-00 ~]# kubectl exec access-79f4758b79-qwl8s nslookup kubernetes-dashboard.kube-system.svc -n kube-system
Server:    10.96.0.10
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes-dashboard.kube-system.svc
Address 1: 10.110.146.248 kubernetes-dashboard.kube-system.svc.cluster.local
[root@fortest1513671663-master-00 ~]# kubectl get svc kubernetes-dashboard -n kube-system
NAME                   TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE
kubernetes-dashboard   NodePort   10.110.146.248   &amp;lt;none&amp;gt;        443:30089/TCP   27m
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>grafana配置教程</title>
      <link>https://sealyun.com/blog/2014/07/11/grafana-promethus/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/grafana-promethus/</guid>
      <description>&lt;h1 id=&#34;grafana配置教程&#34;&gt;grafana配置教程&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../images/grafana/grafana.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>runc 架构破析</title>
      <link>https://sealyun.com/blog/2014/07/11/runc/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/runc/</guid>
      <description>&lt;h2 id=&#34;runc-架构破析&#34;&gt;runc 架构破析&lt;/h2&gt;

&lt;p&gt;这里的spec.Process就是我们真正要运行的容器中的进程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return r.run(&amp;amp;spec.Process)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把这个塞到libcontainer.Process里去了：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何让docker镜像尽可能小</title>
      <link>https://sealyun.com/blog/2014/07/11/scratch/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/scratch/</guid>
      <description>&lt;h1 id=&#34;如何让镜像尽可能小&#34;&gt;如何让镜像尽可能小&lt;/h1&gt;

&lt;p&gt;很容器想到from scratch, 就是没任何基础镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM scratch
COPY p /
ENTRYPOINT [&amp;quot;/p&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>安装包列表</title>
      <link>https://sealyun.com/blog/2014/07/11/offline-install/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/offline-install/</guid>
      <description>&lt;h1 id=&#34;安装包列表&#34;&gt;安装包列表&lt;/h1&gt;

&lt;h2 id=&#34;kubernetes1-10-3离线安装包-审核中&#34;&gt;[kubernetes1.10.3离线安装包 审核中]()&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;全部使用当前最新版本组建&lt;/li&gt;
&lt;li&gt;Cgroup driver自动检测，99%以上一键安装成功，遇到任何问题远程协助解决&lt;/li&gt;
&lt;li&gt;优化dashboard grafana等yaml配置&lt;/li&gt;
&lt;li&gt;DNS双副本高可用&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>离线使用kubeadm安装安全高可用kubernetes集群</title>
      <link>https://sealyun.com/blog/2014/07/11/k8s-offline-install-ha/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/k8s-offline-install-ha/</guid>
      <description>&lt;h1 id=&#34;使用kubeadm安装安全高可用kubernetes集群&#34;&gt;使用kubeadm安装安全高可用kubernetes集群&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://market.aliyun.com/products/57742013/cmxz025618.html?spm=5176.730005.0.0.TFKV5K#sku=yuncode1961800000&#34;&gt;安装包地址&lt;/a&gt; 如非高可用安装请忽略此教程，直接看产品页的三步安装。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;单个master流程：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;解压后在master 上 cd shell  &amp;amp;&amp;amp; sh init.sh ,然后sh master.sh（注意因为脚本用的相对路径所以不再当前目录会找不到文件）&lt;/li&gt;
&lt;li&gt;在node上 cd shell &amp;amp;&amp;amp; sh init.sh  。然后在node上执行master输出的join命令即可&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;高可用如下&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>配置docker engine使engine挂掉时容器继续运行</title>
      <link>https://sealyun.com/blog/2014/07/11/keep_containers_alive_deamon_downtme/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://sealyun.com/blog/2014/07/11/keep_containers_alive_deamon_downtme/</guid>
      <description>&lt;h2 id=&#34;配置docker-engine使engine挂掉时容器继续运行&#34;&gt;配置docker engine使engine挂掉时容器继续运行&lt;/h2&gt;

&lt;p&gt;两种方式：
* 修改/etc/docker/daemon.json 如果不想engine重启，给engine发送SIGHUP信号使engine重新加载配置文件
* 直接加启动参数：&amp;ndash;live-restore,  如用systemd管理修改这个配置文件：/usr/lib/systemd/system/docker.service,
  然后执行systemctl daemon-reload &amp;amp;&amp;amp; service docker restart&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>